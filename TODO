sqlite tests
fix blob resource logic (errors, validation)
blobs resource unit tests
client integration tests
replace smtp transport with http
fix server integration and unit tests
check test coverage
make screenshot collector
deployment scripts

future (collectors)
finish gmail import

future (when I have something I want to query for)
query sqlite tests
query web tests
query client integration tests

future (deployment)
encrypt blobs and store in S3 with a policy to archive to glacier (nice and cheap, recent data is accessible, distant data can still be accessed but is more costly)
    benefit is that MUCH less needs to be stored on the server drive (only the actual event data, which is MUCH smaller)


TEMP:
import sqlite3 as sqlite

# Create a new in-memory DB and a cursor
#
con = sqlite.connect(':memory:')
cur = con.cursor()

# The table is named 'frames'
# The columns are: a running ID, and a data blob
#
cur.execute('''
    create table frames (
        id integer primary key,
        data blob)''')

# Shove some data into the table. The data stored
# using the sqlite.Binary type, which means a BLOB.
#
cur.execute('''
    insert into frames values (null, ?)''',
    (sqlite.Binary('\0' * 10 + '\x12'),))
cur.execute('''
    insert into frames values (null, ?)''',
    (sqlite.Binary('\x01\x42\x55'),))

# Now read it back. When BLOBs are read, they're
# converted to Python buffers of type 'buffer'
#
for row in cur.execute("select * from frames"):
    print row[0], str(row[1]).encode('hex')

cur.close()
con.close()
