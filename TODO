
deploy server to remote small server
    use cherry py probably (or see notes file)
make cpu usage collector (or something similarly simple and reliable)
test that running the collector sends events to the server
use pyinstaller to make installer
test that installed version sends events to the server
make screenshot collector
test that installer works
test that installed version sends events to the server
make configuration dictionary for everything that was hard coded
watch configuration for changes
make app prompt for configuration on first startup
use rumps to make tray on osx with these options:
    preferences (open file in an editor)
    pause/resume
    quit
test installer
test that installed version works
send to justin

future:
check test coverage specifically for unit tests: nosetests --with-coverage --cover-package=memdam tests/unit/
add separate tests for blobstore
add logging
add error reporting
make collector run on windows
decide how to deploy server
    ssl: http://flask.pocoo.org/snippets/111/
    setup dns for joshalbrecht.chronographr.com
    remember to fix logging in wsgi context:
        can use this if necessary: flask.current_app.logger.info('grolsh')
        also remember that memdam.common.parallel may not work in that context... (should test and at least warn)
design continuous deployment and integration process
    probably use circleci
        and eventually send an email thanking that guy :)
    do not want to have to run this infrasturcture myself, it sucks
    mostly have to decide what the targets are (packages, servers, installers, etc)
    for installers, perhaps there can be a "experimental" channel--when I push to master, that is built and uploaded and downloaded and installed and restarted (everywhere)
finish CICD implementation (pushing to master does everything)
    would be awesome to have a running coverage check and linter as well
    probably the linter should be a git commit hook (run locally before you can even commit?)
    probably the same for tests (all have to pass locally before push succeeds)
    in that case...
    anyway, think about it

future (cleanup)
    pylint fixes
    update docs everywhere
    search for and minimize TODOs:
        only use TODOs for functionality that is incomplete, and in those cases, just raise NotImplementedError in most cases instead
        for features, put them here instead
        for cleanup and testing and docs, generally do it immediately, otherwise put it here
    add auto trace logging (AOP)
    make things configurable that should be configurable


future (collectors)
finish gmail import
store in local blob and event store first (much faster), and have a separate process that synchs from one to the other, then deletes from the original

future (when I have something I want to query for)
query sqlite tests
query web tests
query client integration tests

future (UI)
use pyqt probably

future (deployment)
add ability for updates
    eventually, not now
encrypt blobs and store in S3 with a policy to archive to glacier (nice and cheap, recent data is accessible, distant data can still be accessed but is more costly)
    benefit is that MUCH less needs to be stored on the server drive (only the actual event data, which is MUCH smaller)
